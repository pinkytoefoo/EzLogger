// this file is autogenerated by `amalgamate.py`,
// and then edited to make a single header file.
// !realistically, if you want to use a simple header-only file
// !use `ezlog_small.hpp`
//           _             
//   ___ ___| | ___   __ _ 
//  / _ \_  / |/ _ \ / _` |
// |  __// /| | (_) | (_| |
//  \___/___|_|\___/ \__, |
//                   |___/ 

#pragma once

#if defined(_WIN32)
#   include <Windows.h>
#endif

#include <string>
#include <cstdlib>
#include <format>
#include <cstring>

namespace ezlog
{
    enum class color
    {
        default_,
        intensify,
        black,
        red,
        green,
        yellow,
        blue,
        magenta,
        cyan,
        white,
        bright_red,
        bright_green,
        bright_yellow,
        bright_blue,
        bright_magenta,
        bright_cyan,
        bright_white,
    };

    constexpr std::string_view ansi(color c)
    {
        switch (c)
        {
            case color::red:        return "\033[31m";
            case color::green:      return "\033[32m";
            case color::yellow:     return "\033[33m";
            case color::blue:       return "\033[34m";
            case color::magenta:    return "\033[35m";
            case color::cyan:       return "\033[36m";
            case color::white:      return "\033[37m";
            // case color::default_:   return "\033[38m";
            default:                return "\033[00m";
        }
    }

    #if defined(_WIN32)
    constexpr unsigned short win_attr(color c)
    {
        switch (c)
        {
            case color::black:          return 0x0000;
            case color::blue:           return 0x0001;
            case color::green:          return 0x0002;
            case color::bright_blue:    return 0x0003;
            case color::red:            return 0x0004;
            case color::magenta:        return 0x0005;
            case color::yellow:         return 0x0006;
            case color::white:          return 0x0007;
            case color::default_:       return 0x0007;
            case color::intensify:      return 0x0008;
            default:                    return 0x0007;
        }
    }
    #else
    constexpr unsigned short win_attr(color c) { return -1; }
    #endif
    
    namespace detail
    {
        void quick_print(std::string_view s)
        {
            std::fputs(s.data(), stdout);
            std::fputc('\n', stdout);
        }
        
        template<typename... Args>
        void quick_print(std::format_string<Args...> str, Args&&... args)
        {
            std::fputs(std::format(str, std::forward<Args>(args)...).c_str(), stdout);
            std::fputc('\n', stdout);
        }
    }
    
    namespace platform
    {
        enum class backend
        {
            none,
            ansi,
            win32     
        };
        
        backend detect_backend()
        {
        #if defined(_WIN32)
            // windows terminal emulator / ansi capable terminalsS
            if (const char* wt = getenv("WT_SESSION"))
                return backend::ansi;

            HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
            if (h == INVALID_HANDLE_VALUE)
                return backend::none;

            DWORD mode = 0;
            if (GetConsoleMode(h, &mode) &&
                (mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING))
                return backend::ansi;

            return backend::win32;
        #else
            // assume posix and ansi capable terminal
            return color_backend::ansi;
        #endif
        }

        void write_color(std::string_view msg, color c, backend b)
        {
            switch(b)
            {
                case backend::ansi:
                    detail::quick_print("{}{}{}", ansi(c), msg, ansi(color::default_));
                    break;
                case backend::win32:
                #if defined(_WIN32)
                    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), win_attr(c));
                    detail::quick_print("{}", msg);
                    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), win_attr(color::default_));
                #endif
                    break;
                // if no api, just log the message (no color)
                case backend::none:
                    detail::quick_print("{}", msg);
                    break;
            }
        }

        template<typename... Args>
        void write_color_fmt(color c, backend b, std::format_string<Args...> str, Args&&... args)
        {
            switch(b)
            {
                case backend::ansi:
                quick_print(str, ansi(c), std::forward<Args>(args)..., ansi(color::default_));
                break;
                case backend::win32:
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), win_attr(c));
                quick_print(str, std::forward<Args>(args)...);
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), win_attr(color::default_));
                break;
                // if no api, just log the message (no color)
                case backend::none:
                quick_print(str, std::forward<Args>(args)...);
                break;
            }
        }
    }

    enum class level
    {
        trace, info, warn, error,
    };
    
    static platform::backend g_backend = platform::detect_backend();

    class logger
    {
    public:
        logger()
            : level_{level::trace}
        {
        }

        logger(level lvl)
            : level_{lvl}
        {
        }
        ~logger() = default;

        void log(std::string_view msg, color c)
        {
            write(msg, c);
        }
        template<typename... Args>
        void log(color c, std::format_string<Args...> str, Args&&... args)
        {
            write(std::format(str, std::forward<Args>(args)...), c);
        }

        void trace(std::string_view msg)
        {
            log_if(msg, level::trace);
        }

        void info(std::string_view msg)
        {
            log_if(msg, level::info, color::green);
        }

        void warn(std::string_view msg)
        {
            log_if(msg, level::warn, color::yellow);
        }

        void error(std::string_view msg)
        {
            log_if(msg, level::error, color::red);
        }
    private:
        void log_if(std::string_view msg, level lvl, color c = color::default_)
        {
            if(lvl >= level_)
                write(msg, c);
        }

        void write(std::string_view msg, color c)
        {
            platform::write_color(msg, c, g_backend);
        }
        
        level level_{level::trace};
    };
}
